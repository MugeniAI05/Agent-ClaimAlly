# -*- coding: utf-8 -*-
"""tools.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G6Wr1SFw8rmISZ_snN4TQWtf9aFNFWlc
"""

# TOOLS

def fetch_market_data(
    tool_context: ToolContext,
    ticker: str = "SPY",
    period: str = "1y"
) -> dict:
    """Fetches real historical price data from Yahoo Finance and saves it to session state."""
    print(f"--- Tool: Fetching real data for {ticker} ---")
    try:
        df = yf.download(ticker, period=period, progress=False)
        if df.empty:
            return {"status": "error", "message": f"No data found for ticker {ticker}."}
        if isinstance(df.columns, pd.MultiIndex):
            df = df.xs('Close', axis=1, level=0)
        else:
            if 'Close' in df.columns:
                df = df[['Close']]
        prices = df.squeeze().tolist()
        dates = df.index.strftime('%Y-%m-%d').tolist()
    except Exception as e:
        return {"status": "error", "message": f"API Error: {str(e)}"}

    data_payload = {"ticker": ticker.upper(), "n_days": len(prices), "dates": dates, "prices": prices}
    tool_context.state["market_data"] = data_payload
    return {"status": "success", "message": f"Fetched {len(prices)} days for {ticker}.", "saved_to_state": True}

def compute_simple_factors(tool_context: ToolContext) -> dict:
    """Computes factors using 'market_data' found in session state."""
    price_payload = tool_context.state.get("market_data")
    if not price_payload:
        return {"status": "error", "message": "No market data found."}

    prices = np.array(price_payload["prices"], dtype=float)
    mom_5d = np.concatenate((np.full(5, np.nan), prices[5:] / prices[:-5] - 1.0))
    mom_20d = np.concatenate((np.full(20, np.nan), prices[20:] / prices[:-20] - 1.0))

    log_ret = np.diff(np.log(prices))
    vol_20d = np.full_like(prices, np.nan, dtype=float)
    if len(log_ret) >= 20:
        roll = pd.Series(log_ret).rolling(20).std() * math.sqrt(252)
        vol_20d[1:] = roll.values

    tool_context.state["factor_data"] = {
        "mom_5d": mom_5d.tolist(), "mom_20d": mom_20d.tolist(), "vol_20d": vol_20d.tolist()
    }
    return {"status": "success", "message": "Computed factors. Saved to session state.", "factor_names": ["mom_5d", "mom_20d", "vol_20d"]}

def local_backtest(tool_context: ToolContext, factor_name: str) -> dict:
    """Backtests a specific factor using data stored in session state."""
    factor_payload = tool_context.state.get("factor_data")
    if not factor_payload or factor_name not in factor_payload:
        return {"status": "error", "message": f"Factor {factor_name} not found."}

    series = np.nan_to_num(np.array(factor_payload[factor_name], dtype=float), nan=0.0)
    strat_ret = 0.01 * series

    sharpe = 0.0 if strat_ret.std() == 0 else float(strat_ret.mean() / strat_ret.std() * math.sqrt(252))
    total_return = float((1.0 + strat_ret).prod() - 1.0)

    cum = (1.0 + strat_ret).cumprod()
    max_dd = float(((cum - np.maximum.accumulate(cum)) / np.maximum.accumulate(cum)).min())

    return {"factor": factor_name, "sharpe": sharpe, "cagr": total_return, "max_drawdown": max_dd}